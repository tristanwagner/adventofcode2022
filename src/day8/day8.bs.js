// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Fs from "fs";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Caml_array from "rescript/lib/es6/caml_array.js";
import * as Caml_format from "rescript/lib/es6/caml_format.js";

var input = Fs.readFileSync("input.txt", "ascii");

var lines = input.split("\n").slice(0, -1);

var grid = lines.reduce((function (acc, current) {
        acc.push(current.split("").map(Caml_format.int_of_string));
        return acc;
      }), []);

var edge = ((grid.length << 1) - 4 | 0) + (Caml_array.get(grid, 0).length << 1) | 0;

var dict = {};

for(var x = 1 ,x_finish = grid.length - 2 | 0; x <= x_finish; ++x){
  for(var y = 1 ,y_finish = Caml_array.get(grid, x).length - 2 | 0; y <= y_finish; ++y){
    var tree = Caml_array.get(Caml_array.get(grid, x), y);
    var visibleLeft = true;
    for(var l = y - 1 | 0; l >= 0; --l){
      if (Caml_array.get(Caml_array.get(grid, x), l) >= tree) {
        visibleLeft = false;
      }
      
    }
    var visibleRight = true;
    for(var r = y + 1 | 0 ,r_finish = Caml_array.get(grid, x).length; r < r_finish; ++r){
      if (Caml_array.get(Caml_array.get(grid, x), r) >= tree) {
        visibleRight = false;
      }
      
    }
    var visibleTop = true;
    for(var t = x - 1 | 0; t >= 0; --t){
      if (Caml_array.get(Caml_array.get(grid, t), y) >= tree) {
        visibleTop = false;
      }
      
    }
    var visibleBottom = true;
    for(var b = x + 1 | 0 ,b_finish = grid.length; b < b_finish; ++b){
      if (Caml_array.get(Caml_array.get(grid, b), y) >= tree) {
        visibleBottom = false;
      }
      
    }
    if (visibleLeft || visibleRight || visibleTop || visibleBottom) {
      dict["" + String(x) + "-" + String(y) + ""] = 1;
    }
    
  }
}

var visibleTrees = Js_dict.values(dict).length + edge | 0;

console.log("Part 1:", visibleTrees);

var dict2 = {};

for(var x$1 = 0 ,x_finish$1 = grid.length; x$1 < x_finish$1; ++x$1){
  for(var y$1 = 0 ,y_finish$1 = Caml_array.get(grid, x$1).length; y$1 < y_finish$1; ++y$1){
    var tree$1 = Caml_array.get(Caml_array.get(grid, x$1), y$1);
    var blockedLeft = false;
    var scoreLeft = 0;
    for(var l$1 = y$1 - 1 | 0; l$1 >= 0; --l$1){
      if (!blockedLeft) {
        scoreLeft = scoreLeft + 1 | 0;
        if (Caml_array.get(Caml_array.get(grid, x$1), l$1) >= tree$1) {
          blockedLeft = true;
        }
        
      }
      
    }
    var blockedRight = false;
    var scoreRight = 0;
    for(var r$1 = y$1 + 1 | 0 ,r_finish$1 = Caml_array.get(grid, x$1).length; r$1 < r_finish$1; ++r$1){
      if (!blockedRight) {
        scoreRight = scoreRight + 1 | 0;
        if (Caml_array.get(Caml_array.get(grid, x$1), r$1) >= tree$1) {
          blockedRight = true;
        }
        
      }
      
    }
    var blockedTop = false;
    var scoreTop = 0;
    for(var t$1 = x$1 - 1 | 0; t$1 >= 0; --t$1){
      if (!blockedTop) {
        scoreTop = scoreTop + 1 | 0;
        if (Caml_array.get(Caml_array.get(grid, t$1), y$1) >= tree$1) {
          blockedTop = true;
        }
        
      }
      
    }
    var blockedBottom = false;
    var scoreBottom = 0;
    for(var b$1 = x$1 + 1 | 0 ,b_finish$1 = grid.length; b$1 < b_finish$1; ++b$1){
      if (!blockedBottom) {
        scoreBottom = scoreBottom + 1 | 0;
        if (Caml_array.get(Caml_array.get(grid, b$1), y$1) >= tree$1) {
          blockedBottom = true;
        }
        
      }
      
    }
    dict2["" + String(x$1) + "-" + String(y$1) + ""] = Math.imul(Math.imul(Math.imul(scoreTop, scoreLeft), scoreRight), scoreBottom);
  }
}

var result2 = Js_dict.values(dict2).sort(function (n1, n2) {
      return n2 - n1 | 0;
    });

console.log("Part 2:", Caml_array.get(result2, 0));

export {
  input ,
  lines ,
  grid ,
  edge ,
  dict ,
  visibleTrees ,
  dict2 ,
  result2 ,
}
/* input Not a pure module */
